# Classic Semaphore Problems from The Little Book of Semaphores

This repository contains my implementations of classic synchronization problems from The Little Book of Semaphores. These implementations were created as part of my learning process during the Operating Systems course.


## Features

This repository includes implementations of the following classic synchronization problems:
 - Unisex Bathroom
 - Sleeping Barber
 - Cannibals
 - Sleeping Philosophers
 - Smokers
 - H2o
 - Printers
 - Readers/Writers
 - Producer/Consumer
 - Sequence 
 - Sushi-Bar

## Lessons Learned

Working on this project allowed me to deepen my understanding of synchronization and concurrency in operating systems. These are some of the key lessons and skills I developed:

* Diverse Implementation Techniques: Implemented solutions using a variety of inter-process communication (IPC) mechanisms, including semaphores, shared memory, message queues, and pipes. Each approach provided unique challenges and insights into process synchronization.
* Problem-Solving Without Global Variables: Designed solutions that avoided global variables, relying entirely on synchronization mechanisms like semaphores to manage shared resources.
* Concurrency and Deadlock Handling: Explored techniques to prevent and resolve deadlocks, starvation, and race conditions in complex multi-threaded or multi-process environments.
* Practical Knowledge of Semaphores: Gained a solid understanding of semaphores and their critical role in managing concurrency and ensuring mutual exclusion.
* Inter-Process Coordination: Learned to coordinate processes effectively using advanced IPC techniques, improving both my technical knowledge and problem-solving skills.
* Code Optimization: Focused on writing clean, efficient, and maintainable code that balances clarity and performance.

This project not only strengthened my technical skills but also gave me hands-on experience with the critical tools and concepts required for designing robust and synchronized systems.
